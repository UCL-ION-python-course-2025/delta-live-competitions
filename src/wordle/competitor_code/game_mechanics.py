import copy
import os
import pickle
import random
import time
from typing import Callable, Dict, List

import numpy as np

from possible_words import possible_words
from visualisation import WorldleVisualisationController

possible_words = possible_words()


############ Please do not edit this file!!!!! ###########################


def get_wordle_tile_colors(answer: str, guess: str) -> List[int]:
    """Given the true `answer` and your `guess`, returns the.

    list of 'tile colors' - the feedback as to which letters
    match and which don't.

    2 = correct place
    1 = letter in word but different place
    0 = letter not in word

    Example: If `answer` == "scram", `guess` == "parse",
        then this should output [0, 1, 2, 1, 0]

    Args:
        answer: 5-letter word that's the answer that you're
            trying to guess
        guess: your 5-letter word guess

    Returns:
        The list of numbers corresponding to matches between
        the answer and guess according to where they are in
        your guess.
    """
    assert isinstance(
        answer, str
    ), f"answer must be a string, instead is {type(answer)}"
    assert isinstance(guess, str), f"guess must be a string, instead is {type(guess)}"
    assert len(answer) == len(guess), "answer and guess must be the same length"
    result = [0] * 5

    # Greens
    remaining_letters_in_actual_word = []
    possible_ones_in_guess = []
    for count, (l1, l2) in enumerate(zip(answer, guess)):
        if l1 == l2:
            result[count] = 2
        else:
            remaining_letters_in_actual_word.append(l1)
            possible_ones_in_guess.append(l2)

    for poss_one in possible_ones_in_guess:
        # check if it's a 1
        if poss_one in remaining_letters_in_actual_word:
            for count, (res, letter) in enumerate(zip(result, guess)):
                if res == 0 and letter == poss_one:
                    result[count] = 1
                    break
            remaining_letters_in_actual_word.remove(poss_one)

    return result


########### You don't need to use anything below this line ##############


def play_wordle(
    take_action: Callable[[dict], str], game_speed_multiplier: float
) -> None:
    game = Wordle("", game_speed_multiplier)
    game.play_standalone_game(take_action)
    return


def play_n_games(take_action: Callable[[dict], str], number_of_games: int) -> float:
    """Runs number_of_games games and returns the average number of guesses per game."""

    n_guesses = 0
    for _ in range(number_of_games):
        game = Wordle("", 10000)
        game.play_game_no_visualisation(take_action)
        n_guesses += game.n_guesses

    return n_guesses / number_of_games


class Wordle:
    def __init__(self, team_name: str, game_speed_multiplier: float) -> None:
        self.n_guesses_allowed = 6
        self.team_name = team_name
        self.game_speed_multiplier = game_speed_multiplier
        self.visualisation_controller = WorldleVisualisationController(
            self.team_name, self.game_speed_multiplier
        )
        self.reset(np.random.randint(0, 100))

    def reset(self, random_seed: int = 42) -> None:
        self.game_over = False
        self.solved = False
        self.n_guesses = 0
        self._word = self.weighted_random_word(random_seed)
        self.previous_guesses: Dict[str, List[int]] = {}
        self.visualisation_controller.reset()

    def weighted_random_word(self, random_seed: int, weight_strength: float = 1) -> str:
        """With a weight_strength of 1, chooses the most common 5 letter word "which".

        ~5% of the time, and "their" the second most common ~2.8% of the time.
        """

        # Fix path
        np.random.seed(random_seed)
        with open(
            os.path.join(
                os.path.dirname(os.path.realpath(__file__)), "word_use_frequency.pkl"
            ),
            "rb",
        ) as f:
            freq = pickle.load(f)
        weights = np.array(
            [(1 / (freq[word] ** weight_strength)) for word in possible_words]
        )
        weights = weights / np.sum(weights)
        return np.random.choice(possible_words, p=weights)

    def make_guess(self, guess: str) -> List[int]:

        assert guess is not None, "Your function did not return anything!"
        assert (
            len(guess) == 5
        ), f"Invalid guess. You guessed: {guess}\n\nGuesses must be 5 letters long"
        assert (
            guess in possible_words
        ), f"Invalid guess. You guessed: {guess}\n\nGuess must be in the possible_words list"
        return get_wordle_tile_colors(self._word, guess)

    def play_standalone_game(self, take_action: Callable[[dict], str]) -> None:

        self.visualisation_controller.draw_standalone_game()
        while not self.solved and not self.game_over:
            self.update(take_action)

    def play_game_no_visualisation(self, take_action: Callable[[dict], str]) -> None:
        while not self.solved and not self.game_over:
            self.update(take_action, display=False)

    def update(self, take_action: Callable[[dict], str], display: bool = True) -> None:
        try:
            guess = take_action(self.previous_guesses).lower()
        except:
            guess = random.choice(possible_words)
        result = None
        while result is None:
            try:
                result = self.make_guess(guess)
            except:
                guess = random.choice(possible_words)
        if display:
            self.visualisation_controller.display_word(guess, result)
        self.previous_guesses[guess] = result
        self.n_guesses += 1
        time.sleep(1 / self.game_speed_multiplier)

        if sum(result) == 10:
            if display:
                self.visualisation_controller.display_winning_text(
                    self.n_guesses, guess
                )
            self.solved = True
        elif self.n_guesses == self.n_guesses_allowed:
            if display:
                self.visualisation_controller.display_game_over_text(
                    self.n_guesses_allowed, correct_word=self._word
                )
            self.game_over = True
