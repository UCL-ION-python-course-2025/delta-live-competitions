"""DO NOT EDIT THIS FILE!

This is a set of functions and classes written by Delta to be used by you during the challenge.

# There are a number of utility functions that you may find extremely useful for your solution!

Read the README for more info!!
"""
import enum
import random
from collections import Counter
from time import sleep
from typing import Callable, List, Optional

import numpy as np

# Constants used in the game
GRID_DIMS = (4, 4)


# You can refer to these `Action`s like this: `Action.UP`
class Action(enum.Enum):
    # The direction you'd 'swipe' the board
    UP = 0
    RIGHT = 1
    DOWN = 2
    LEFT = 3


#### TO TEST YOUR SOLUTION ON THE GAME
def play_2048(
    take_action: Callable[[np.ndarray], "Action"],  # The function you're writing
    game_speed_multiplier: float = 1.0,  # This speeds up the simulation :)
) -> None:
    """Play a game of 2048."""
    game = TwentyFortyEight()
    game.play_round(take_action, game_speed_multiplier)
    print(f"Game over! Score: {game.score}. Your highest tile was: {game.highest_tile}")


##### HELPER FUNCTIONS - FEEL FREE TO USE THESE!


def get_possible_moves(grid: np.ndarray) -> List[Action]:
    """For a given 2048 grid, this function returns a list of all the valid actions that can be
    taken.

    Args:
        grid: np.ndarray (4,4) with the numbers of the current game state

    Returns:
        a list of the actions that are valid for this game state (grid)
    """

    grid_copy = grid.copy()
    return [
        move
        for move in [Action.UP, Action.DOWN, Action.LEFT, Action.RIGHT]
        if not np.all(grid == update_grid(grid_copy, move))
    ]


def slide_up(grid: np.ndarray) -> np.ndarray:
    """Takes a grid and returns it after a swipe up is taken.

    Args:
        grid: np.ndarray (4,4) with a 2048 game state

    Returns:
        grid: np.ndarray (4,4) with updated game state after an upward swipe
    """
    for row_idx, row in enumerate(grid):
        for col_idx, item in enumerate(row):
            if item != 0:
                for item_above_count, item_above in enumerate(reversed(grid[:row_idx, col_idx])):
                    if item_above != 0 or row_idx - item_above_count == 1:
                        grid[row_idx, col_idx] = 0
                        is_item_above = item_above != 0
                        new_row_idx = (
                            row_idx - item_above_count
                            if is_item_above
                            else row_idx - item_above_count - 1
                        )
                        grid[new_row_idx, col_idx] = item
                        break
    return grid


def combine_tiles_vertically(grid: np.ndarray) -> np.ndarray:
    """Takes a grid and combines tiles with the same value in the vertical direction. Tiles with the
    same value in the vertical direction will sum and move up, replaced by a 0 below.

    Args:
        grid: np.ndarray (4,4) with a 2048 game state

    Returns:
        grid: np.ndarray (4,4) with a 2048 game state, updated with vertical combinations of adjacent tiles with the same value
    """

    for row_idx, row in enumerate(grid):
        for col_idx, item in enumerate(row):
            if item != 0:
                for item_below_count, item_below in enumerate(grid[row_idx + 1 :, col_idx]):
                    if item_below not in [0, item]:
                        break
                    elif item_below == item:
                        # merge those mfs
                        grid[row_idx, col_idx] = 2 * item
                        grid[row_idx + item_below_count + 1, col_idx] = 0
                        break
    return grid


def update_grid(grid: np.ndarray, action: Action) -> np.ndarray:
    """Takes a grid and an action and returns the updated grid. Depends on functions
    'combine_tiles_vertically' and 'slide_up'.

    Args:
        grid: np.ndarray (4,4). An array representing a 2048 game state.
        action: an action to be taken in 2048. Can take actions (Action.UP, Action.DOWN, Action.LEFT, Action.RIGHT), which correspond to swipes on the board.

    Returns:
        grid: np.ndarray(4,4). An updated array of the game state depending on the action taken.
    """
    grid = np.rot90(grid, action.value)
    grid = combine_tiles_vertically(grid)
    grid = slide_up(grid)
    return np.rot90(grid, -action.value)


def is_game_over(grid: np.ndarray) -> bool:
    """Checks whether the game is over.

    Args:
        grid: np.ndarray (4, 4). An array representing a 2048 game state.

    Returns:
        A boolean of whether the game is finished.
    """
    return len(get_possible_moves(grid)) == 0


def get_corner_tiles(grid: np.ndarray) -> np.ndarray:
    """Returns the four corner tiles of the grid as a flat (4x1) array."""
    return grid[0::3, 0::3].flatten()


def get_side_tiles(grid: np.ndarray) -> np.ndarray:
    """Returns the eight side (not corner) tiles of the grid as a flat (8x1) array."""
    return np.append(grid[1:3, 0::3], grid[0::3, 1:3])


def sample_tile_number() -> int:
    """Draws the number that the next tile that spawns in will be.

    As in the real game, 90% of the time the tile is a 2 and 10% of the time it's a 4.
    """
    return np.random.choice([2, 4], p=[0.9, 0.1])


##################################################################
#### BELOW FUNCTIONS AREN'T WORTH READING - THEY RUN THE GAME ####
##################################################################


class TwentyFortyEight:
    def __init__(self, competition: bool = False) -> None:
        self.reset()
        self.display_board()
        self.competition = competition
        self.last_move: Optional[Action] = None

    def reset(self) -> None:
        self.score = 0
        self.board = self.blank_board
        chosen_tile_ints = np.random.choice(range(16), replace=False, size=3)
        for tile_location in chosen_tile_ints:
            self.board[tile_location // 4, tile_location % 4] = sample_tile_number()

    def __repr__(self) -> str:
        """Return a string representation of the game state such that x and y are correctly
        aligned."""
        return str(self.board)

    def play_round(
        self, take_action: Callable[[np.ndarray], "Action"], game_speed_multiplier: float = 1.0
    ) -> None:
        """Play a round of the game."""
        while not self.game_over:
            self.update(take_action)
            sleep(0.2 / game_speed_multiplier)

    def update(self, take_action: Callable[[np.ndarray], "Action"]) -> None:
        """Update the game state."""
        action = take_action(self.board.copy())

        # If action is invalid, error
        if not self.competition:
            print("action taken:", action)
            assert (
                action in self.possible_actions
            ), f"Action: {action} not one of the possible actions: {self.possible_actions}"
        elif action.value not in [poss.value for poss in self.possible_actions]:
            action = random.choice(self.possible_actions)

        self.last_move = action

        # Update the board
        self.board = np.rot90(self.board, k=action.value)
        self.combine_tiles()
        self.slide_up()
        self.spawn_new_tile()
        self.board = np.rot90(self.board, k=-action.value)
        if not self.competition:
            self.display_board()

    def spawn_new_tile(self) -> None:
        """Spawn a new tile."""
        assert not self.game_over
        self.board[
            random.choice([tuple(loc) for loc in self.empty_locations])
        ] = sample_tile_number()

    def slide_up(self) -> None:
        """Slide all tiles up."""
        self.board = slide_up(self.board)

    def combine_tiles(self) -> None:
        """Combine all tiles that can be combined vertically."""
        tiles_before_combining = Counter([tile for row in self.board for tile in row])
        self.board = combine_tiles_vertically(self.board)
        tiles_after_combining = Counter([tile for row in self.board for tile in row])
        for tile, post_count in tiles_after_combining.items():
            pre_count = tiles_before_combining.get(tile, 0)
            if post_count > pre_count:
                self.score += (post_count - pre_count) * tile

    def display_board(self) -> None:
        print(self, "\n")

    @property
    def tile_locations(self) -> np.ndarray:
        """Return a list of all tile locations."""
        return np.array(np.where(self.board != 0)).T

    @property
    def empty_locations(self) -> np.ndarray:
        """Return a list of all empty locations."""
        return np.array(np.where(self.board == 0)).T

    @property
    def possible_actions(self) -> List["Action"]:
        """Return a list of all possible actions."""
        return [
            move
            for move in [Action.UP, Action.DOWN, Action.LEFT, Action.RIGHT]
            if np.any(self.board != update_grid(self.board.copy(), move))
        ]

    @property
    def blank_board(self) -> np.ndarray:
        return np.zeros((4, 4), dtype=int)

    @property
    def highest_tile(self) -> int:
        return np.max(self.board)

    @property
    def game_over(self) -> bool:
        """Return True if the game is over."""
        return not self.possible_actions
